问题题目：x86计算机启动过程中软件被硬件强制必须遵守“多此一举”的步骤，举例说明，并设计替代方案。

答：
  以下内容为我的个人理解，如有错误欢迎学长/老师指出。
  首先说一下x86计算机。intel通用计算机缩写，其最大的特点应是在于标识一套通用的计算机指令集。正因为如此，它的兼容性是显而易见的。我的电脑即是x86的32位机。经过多年的发展历程，从i8086，8088芯片等16位微处理器，一直到现在的电脑cpu，基本x86指令集的cpu可以运行所有intel cpu所开发的各种软件，形成今天庞大的x86系列及兼容cpu阵容。
  虽然如此，在发展历程中，为了保持计算机的兼容性，确实软件有受到一些限制。从这次的实验中体会的比较深刻。程序运行过程中，首先为了防止某个寄存器的值被改变，必须在许多的地方用到堆栈，用于寄存器的还原。例如在setup.s文件中开始第一句话便是mov ax,#INITSEG,这个应该已经在bootsect.s中设置过了，但是还需要重新的设置一遍。系统启动页面为了输出某个值需要精确计算它的地址和偏移量，同时各自不同的打印程序无疑增添了代码量和时间复杂性。
  同时为了防止内存的覆盖，也用到了特别处理。举例说明：bootsect引导程序是将system模块读到0x10000(64k)开始的位置，由于但是假设system模块最大长度不会超过0x80000(512k),即其末端不会超过0x90000,所以bootsect会将自己移动到0x90000的位置，并把setup加载到自己后面，若是发生覆盖，则会发生系统崩溃，所以编写地址时需要非常小心谨慎。然后开机时BIOS开始移动到0x7c00，执行时为了加载主模块，又会移到相对靠后位置，此即“多此一举”了。
  解决办法：优化代码，尽量节省内存空间，空出的内存地址用0补齐，访问跳过这些空间（这是参考setup来了，不知到是否可行）。还可以扩大BIOS的内存地址访问范围，防止内存的覆盖。
